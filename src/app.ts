import str from 'string-to-stream'
import { PNG } from 'pngjs/browser'
import { imagenetClasses } from './imagenet'
import { Tensor, run } from '@cloudflare/constellation'

import { Bindings } from './types'

export async function processImage(env: Bindings, data: ArrayBuffer) {
  let result

  const input = await decodeImage(data).catch((err) => {
    result = err
  })

  if (input) {
    const tensorInput = new Tensor('float32', [1, 3, 224, 224], input)

    const output = await run(env.CLASSIFIER, env.MODEL_ID, tensorInput)

    const predictions = output.squeezenet0_flatten0_reshape0.value
    const softmaxResult = softmax(predictions)
    const results = topClasses(softmaxResult, 5)

    result = results[0]
  }

  return result
}

/* The model expects input images normalized in the same way, i.e. mini-batches of 3-channel RGB images
   of shape (N x 3 x H x W), where N is the batch size, and H and W are expected to be 224. */

async function decodeImage(buffer: ArrayBuffer, width: number = 224, height: number = 224): Promise<any> {
  return new Promise(async (ok, err) => {
    // convert string to stream
    const stream: any = str(buffer as unknown as string)

    stream
      .pipe(
        new PNG({
          filterType: 4
        })
      )
      .on('parsed', function (this: any) {
        if (this.width != width || this.height != height) {
          err({
            err: `expected width to be ${width}x${height}, given ${this.width}x${this.height}`
          })
        } else {
          const [redArray, greenArray, blueArray] = new Array(
            new Array<number>(),
            new Array<number>(),
            new Array<number>()
          )

          for (let i = 0; i < this.data.length; i += 4) {
            redArray.push(this.data[i] / 255.0)
            greenArray.push(this.data[i + 1] / 255.0)
            blueArray.push(this.data[i + 2] / 255.0)
            // skip data[i + 3] to filter out the alpha channel
          }

          const transposedData = redArray.concat(greenArray).concat(blueArray)
          ok(transposedData)
        }
      })
      .on('error', function (error: any) {
        err({ err: error.toString() })
      })
  })
}

// Refer to https://en.wikipedia.org/wiki/Softmax_function
// Transforms values to between 0 and 1
// The sum of all outputs generated by softmax is 1.

function softmax(resultArray: number[]): any {
  const largestNumber = Math.max(...resultArray)
  const sumOfExp = resultArray
    .map((resultItem) => Math.exp(resultItem - largestNumber))
    .reduce((prevNumber, currentNumber) => prevNumber + currentNumber)
  return resultArray.map((resultValue) => {
    return Math.exp(resultValue - largestNumber) / sumOfExp
  })
}

/* Get the top n classes from ImagetNet */

export function topClasses(classProbabilities: any, n = 5) {
  const probabilities = ArrayBuffer.isView(classProbabilities)
    ? Array.prototype.slice.call(classProbabilities)
    : classProbabilities

  const sorted = probabilities
    .map((prob: any, index: number) => [prob, index])
    .sort((a: Array<number>, b: Array<number>) => {
      return a[0] == b[0] ? 0 : a[0] > b[0] ? -1 : 1
    })

  const top = sorted.slice(0, n).map((probIndex: Array<number>) => {
    const iClass = imagenetClasses[probIndex[1]]
    return {
      id: iClass[0],
      index: parseInt(probIndex[1].toString(), 10),
      name: iClass[1].replace(/_/g, ' '),
      probability: probIndex[0]
    }
  })

  return top
}
